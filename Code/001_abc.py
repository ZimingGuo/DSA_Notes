# author: Ziming Guo
# time: 2020/8/17

# 如果 a+b+c=1000，且 a^2+b^2=c^2（a,b,c 为自然数），如何求出所有a、b、c可能的组合?

# c = 1000-a-b

import time

# # 计算下运行时间
# start_time = time.time()
# for a in range(0, 1001):
#     for b in range(0, 1001):
#         for c in range(0, 1001):
#             if a + b + c == 1000 and a ** 2 + b ** 2 == c ** 2:
#                 print("a, b, c:%d,%d,%d" % (a, b, c))

# 计算下运行时间
start_time = time.time()
for a in range(0, 1001):
    for b in range(0, 1001):
        c = 1000 - a - b
        if a ** 2 + b ** 2 == c ** 2:
            print("a, b, c:%d,%d,%d" % (a, b, c))

end_time = time.time()
print("times:%d" % (end_time - start_time))
print("finished")
# 计算上述程序的时间复杂度：T(n) = n * n * (1 + max(1, 0)) = n^2 * 2 =  O(n^2) (忽略掉常数项和次要项，然后用大O扩起来)


# 1000次 时间复杂度：T = 1000 * 1000 * 1000 * 2
# 2000次 时间复杂度：T = 2000 * 2000 * 2000 * 2
# 推广：T = N * N * N * 2
# 即 最终的时间复杂度是和所解决的问题的规模有关的：T(n) = n^3 * 2 / T(n) = n^3  *10
# 这个 T(n) 就是算法的时间复杂度
# 分析问题的时候，数量级是一个比较直观的评价的体现
# 再推广：g(n) = n^3 （系数并不会影响曲线的走势）
"""
T(n) = k * g(n) 只差了一个常数 k 就可以认为 g(n) 是 T(n) 的渐进函数
将算法时间复杂度算式忽略其系数和常量因子，只留下一个和 N 有关的算式，这个算式就是算法的时间复杂度的大O表示法
N 代表的是要解决的问题的规模
"""

# 算法的时间复杂度是和所处理的数据有关的
# 对于同样一个算法，处理的数据不同，最终的执行步骤(计算量)也可能是不同的
#   即: 排序算法处理的数据，如果给出的数据本身就是排好序的，算法就可以达到最优的时间复杂度，即不用进行排序操作，便利一遍查看一下是否是顺序的就可以
#       最坏的情况就是这是一个无序的数列，需要进行排序

"""

大O表示法下的时间复杂度：
    1）基本操作(复杂度和问题规模无关，是个常量不会发生变化)的时间复杂度为 O(1) 即操作中只有常数项，遇到一个基本操作时间复杂度就 +1
    2）顺序结构：采用开发进行计算
    3）条件结构：取时间复杂度的最大值（最坏情况）
    4）循环结构：乘法进行计算
        2 3 4 代表着所有的事件执行纯顺序，因此所有的编程语言都是包含这三个组成部分的
    5）只关注操作数量的最高次项，其他的次要项和常数项可以忽略掉 (除了忽略常数项还要忽略次要项，即次高次项，只保留最高次项)
    6）如果没有特殊说明，指的就是最坏的时间复杂度

"""


