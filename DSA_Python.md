## Intro
+ 算法的实现和语言没有关系，语言只是实现算法的一个手段，重要的是思想
##### 时间复杂度
+ 每台机器的执行时间是不同的，虽机器的不同而不同，但是每一台机器执行的总的计算的数量是相同的
+ 可以用计算的步骤的数量描述算法的复杂程度
+ 时间复杂度：算法要执行的计算的数量的总和
+ 时间复杂度的排序：
O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)
#### list 的时间复杂度
+ index[] 通过 index 寻找元素，通过一步就可以实现对元素的查找，而不是从头到尾的依次遍历
+ index assignment 向列表中增加值，也是一步操作就可以实现，复杂度还是1
#### 数据结构
+ 算法关注的是问题的解决步骤和解决思路
+ 数据结构关注的是 算法处理的是什么样的数据
+ 在处理数据的过程中，数据的组织方式（用什么类型来保存）和最终执行操作的时候的算法效率紧密相关的。数据的组织方式即数据结构
+ python 中的 list dict set tuple 都是 python 已经封装好的高级的数据结构了，不是基本数据类型，数据结构就是对基本数据类型的封装
+ 基本数据类型：整型 浮点型 字符串
+ 基本的数据操作有五种：增 删 改 查 排序
+ 基本数据类型所占内存大小：
> 一个字节占8位
> 一个整型数据占4个字节（4个基本储存单元）
char 表示字符串中的一个字符，一个字符占一个字节（一个基本储存单元）
+ 数据类型表示：1.什么数据类型 2.数据所占内存的大小
+ 所有的高级的数据结构都是由基本的数据类型所构成的

## 顺序表
+ 变量名称其实指向的是存储空间的起始地址
+ 在寻找指定元素的时候，确定存储的数据类型，数据类型对应着数据在内存中的偏移量。起始位置加上偏移量即想要找的数据的起始位置。
+ 数据的第一个索引值标号为 0，表示的是偏移量为 0，因此应该用 0 表示第一个数据的标号
#### 两种形式
+ 一个字节就是8位 
+ 在系统中申请的内容空间中不再存储元素本身，而是存储元素的地址。
+ 列表里的元素不仅可以存储相同的数据类型，还可以存储不同的数据类型（有整数还有字符串）
+ 即 当列表中的数据类型不同的情况下（基本单元的大小不统一了），而顺序表要保证每一个基本单元的大小是统一的，因此用元素外置的顺序表更适合。
+ 地址也是一条数据，在计算机中地址所占的大小是统一的。32bit的计算机会用4个字节来存储地址信息
+ 因为每一个地址所占的内存大小是相同的，因此可以在顺序表中每一个位置存储的是数据的地址，通过地址去真正的指向我们要存储的数据
+ 先把随意找一个存储单元把数据存储起来，在获取这些存储单元的起始地址，将这些地址作为一个顺序表的基本存储
+ 存储地址的这个顺序表是连续的，每一个存储单元大小是两个字节，内部的数据是所存储数据的地址的起始值
#### 两种实现方式
> 一体式 & 分离式
+ 一体式的结构易于读取，跳过表头部分能够直接定到数据区；分离式的就要加一步运算，找到数据去的起始位置
+ 一体式实现方式会首先规定好开辟的空间大小，一旦数据量超过了既定的空间，就要重新开辟空间，并进行数据的迁移，然后再释放原来存储的数据。
+ 一体式的实现方式需要改变最开始的表头的位置，而分离式的实现方式不需要改变表头地址。（使用上的区别）
+ 一体式 & 分离式实现方式的异同之处
+ 固定的扩充方式：节省空间
+ 加倍的扩充方式：以空间换时间

## 链表
+ 顺序表和链表的区别：存储的数据必须连续，改变数据的时候要重新建立数据区；链表在增加数据的时候可以实现随时向后添加数据
+ 链表中的每一个节点包括两个部分：数据去和链接区(指针区)
+ 想要用程序实现数据结构及其操作，应该将此数据结构封装成一个类：
> 要把这个这个数据以及它所支持的操作放到一起，形成一个整体，此时就是面向对象中的类的概念。
> 在实现数据结构的时候考虑两点：数据的保存问题 & 对于指定的数据结构支持哪一种操作
#### python 中变量标识的本质
+ 实现变量的交换，存储数据的内存的地址以及数据都没有改变，改变的只是变量名称所指向的地址。即 变量名只是保存着对象的地址
+ python 当中一切皆对象
+ python 中的变量名只是一个名字，维护的只是一块地址，地址指向的内容不同，变量所代表的内容也就是不一样的
+ 在其他语言当中，当构建一个变量的时候就必须要指明这个变量是什么类型的。即 变量名直接代表的就是一块存储空间，存储空间中存储数据，即变量直接对应数据。之后这个变量名就不能再指向另一个数据类型的数据了，因为这个变量名在之前已经声明了它所对应的数据类型，不能再改变数据类型了。
+ all in all，python 中变量并没有保存数据，数据和变量名之间是分开的，数据并不是变量的一部分。python 中的变量赋值的等号是一个指向的箭头，并不是数据和变量名的捆绑。
+ 在 python 中实现单链表的方式其实是和 python 这门语言中的变量的本质有关。
#### python 实现单链表的数据结构
+ python 中的等号表示的是地址的指向
#### 链表和顺序表异同
+ 链表在存储数据的时候，每一个节点之间是分散的，对应到内存中，内存也就是分散的。好处是在操作系统没有整块的内存给分配的时候，链表可以利用内存中的分散区域，把这些区域串起来；顺序表就不能够达到这个效果。
+ 链表占空间比较大，每个节点中除了存储数据，还需要有空间存地址。
+ 在向中间插入数据的操作中，虽然两个表的时间复杂度都是 O(n)，链表复杂度用在了遍历数据上面，顺序表的复杂度用在了数据的搬迁上面。
#### 双向链表
+ 后继结点 
+ 前驱结点 
#### 单向循环链表
让尾结点指向头结点


## 栈和队列
+ 使用这两种数据结构是不需要考虑他们的物理结构的，关心的是这两种数据结构，支持什么样的操作
+ 可以用顺序表的方式实现栈的结构
+ 也可以用链表的方式实现栈的结构（从尾部进，从尾部出）

+ 之前学习的顺序表 & 链表解决的是数据如何存放的问题，有各种各样的方式来操作数据。
+ 栈描述的是操作，线性表描述的是数据如何存放

+ 队列是从一端进入，从另外一端获取
+ 队列的结构也可以用顺序表和链表来实现

## 排序算法
+ 有且不仅有这六种 
+ 将线性表中的无序序列排成有序的序列
1）冒泡排序
2）选择排序
3）插入排序
4）快速排序
5）希尔排序
6）归并排序

+ 对于冒泡排序来说，每遍历一次，都会把最大的数字放在未排序部分的队尾

+ 排序算法的稳定性:
不稳定排序算法可能会在相等的键值中改变纪录的相对次序，但是稳定排序算法从来不会如此


